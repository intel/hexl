<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<doxygen xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="compound.xsd" version="1.8.17">
  <compounddef id="indexpage" kind="page">
    <compoundname>index</compoundname>
    <title>Intel Homomorphic Encryption Acceleration Library (HEXL)</title>
    <briefdescription>
    </briefdescription>
    <detaileddescription>
<para>Intel HEXL is an open-source library which provides efficient implementations of integer arithmetic on Galois fields. Such arithmetic is prevalent in cryptography, particularly in homomorphic encryption (HE) schemes. Intel HEXL targets integer arithmetic with word-sized primes, typically 40-60 bits. Intel HEXL provides an API for 64-bit unsigned integers and targets Intel CPUs.</para>
<sect1 id="index_1autotoc_md1">
<title>Contents</title>
<para><itemizedlist>
<listitem><para><ulink url="#intel-homomorphic-encryption-acceleration-library-hexl">Intel Homomorphic Encryption Acceleration Library (HEXL)</ulink><itemizedlist>
<listitem><para><ulink url="#contents">Contents</ulink></para>
</listitem><listitem><para><ulink url="#introduction">Introduction</ulink></para>
</listitem><listitem><para><ulink url="#building-intel-hexl">Building Intel HEXL</ulink><itemizedlist>
<listitem><para><ulink url="#dependencies">Dependencies</ulink></para>
</listitem><listitem><para><ulink url="#compile-time-options">Compile-time options</ulink></para>
</listitem><listitem><para><ulink url="#compiling-intel-hexl">Compiling Intel HEXL</ulink></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ulink url="#testing-intel-hexl">Testing Intel HEXL</ulink></para>
</listitem><listitem><para><ulink url="#benchmarking-intel-hexl">Benchmarking Intel HEXL</ulink></para>
</listitem><listitem><para><ulink url="#using-intel-hexl">Using Intel HEXL</ulink></para>
</listitem><listitem><para><ulink url="#debugging">Debugging</ulink></para>
</listitem><listitem><para><ulink url="#thread-safety">Thread-safety</ulink></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ulink url="#documentation">Documentation</ulink><itemizedlist>
<listitem><para><ulink url="#doxygen">Doxygen</ulink></para>
</listitem><listitem><para><ulink url="#sphinx">Sphinx</ulink></para>
</listitem></itemizedlist>
</para>
</listitem><listitem><para><ulink url="#contributing">Contributing</ulink><itemizedlist>
<listitem><para><ulink url="#repository-layout">Repository layout</ulink></para>
</listitem></itemizedlist>
</para>
</listitem></itemizedlist>
</para>
</sect1>
<sect1 id="index_1autotoc_md2">
<title>Introduction</title>
<para>Many cryptographic applications, particularly homomorphic encryption (HE), rely on integer polynomial arithmetic in a finite field. HE, which enables computation on encrypted data, typically uses polynomials with degree <computeroutput>N</computeroutput> a power of two roughly in the range <computeroutput>N=[2^{10}, 2^{17}]</computeroutput>. The coefficients of these polynomials are in a finite field with a word-sized primes, <computeroutput>p</computeroutput>, up to <computeroutput>p</computeroutput>~62 bits. More precisely, the polynomials live in the ring <computeroutput>Z_p[X]/(X^N + 1)</computeroutput>. That is, when adding or multiplying two polynomials, each coefficient of the result is reduced by the prime modulus <computeroutput>p</computeroutput>. When multiplying two polynomials, the resulting polynomials of degree <computeroutput>2N</computeroutput> is additionally reduced by taking the remainder when dividing by <computeroutput>X^N+1</computeroutput>.</para>
<para>The primary bottleneck in many HE applications is polynomial-polynomial multiplication in <computeroutput>Z_p[X]/(X^N + 1)</computeroutput>. For efficient implementation, Intel HEXL implements the negacyclic number-theoretic transform (NTT). To multiply two polynomials, <computeroutput>p_1(x), p_2(x)</computeroutput> using the NTT, we perform the FwdNTT on the two input polynomials, then perform an element-wise modular multiplication, and perform the InvNTT on the result.</para>
<para>Intel HEXL implements the following functions:<itemizedlist>
<listitem><para>The forward and inverse negacyclic number-theoretic transform (NTT)</para>
</listitem><listitem><para>Element-wise vector-vector modular multiplication</para>
</listitem><listitem><para>Element-wise vector-scalar modular multiplication with optional addition</para>
</listitem><listitem><para>Element-wise modular multiplication</para>
</listitem></itemizedlist>
</para>
<para>For each function, the library implements one or several Intel(R) AVX-512 implementations, as well as a less performant, more readable native C++ implementation. Intel HEXL will automatically choose the best implementation for the given CPU Intel(R) AVX-512 feature set. In particular, when the modulus <computeroutput>p</computeroutput> is less than <computeroutput>2^{50}</computeroutput>, the AVX512IFMA instruction set available on Intel IceLake server and IceLake client will provide a more efficient implementation.</para>
<para>For additional functionality, see the public headers, located in <computeroutput>include/intel-hexl</computeroutput> </para>
</sect1>
<sect1 id="index_1autotoc_md3">
<title>Building Intel HEXL</title>
<sect2 id="index_1autotoc_md4">
<title>Dependencies</title>
<para>We have tested Intel HEXL on the following operating systems:<itemizedlist>
<listitem><para>Ubuntu 18.04</para>
</listitem><listitem><para>macOS 10.15</para>
</listitem><listitem><para>Microsoft Windows 10</para>
</listitem></itemizedlist>
</para>
<para>Intel HEXL requires the following dependencies:</para>
<para><table rows="3" cols="2"><row>
<entry thead="yes"><para>Dependency </para>
</entry><entry thead="yes"><para>Version  </para>
</entry></row>
<row>
<entry thead="no"><para>CMake </para>
</entry><entry thead="no"><para>&gt;= 3.5.1  </para>
</entry></row>
<row>
<entry thead="no"><para>Compiler </para>
</entry><entry thead="no"><para>gcc &gt;= 7.0, clang++ &gt;= 5.0, MSVC &gt;= 2019  </para>
</entry></row>
</table>
</para>
<para>For best performance, we recommend using a processor with AVX512-IFMA52 support, and a recent compiler (gcc &gt;= 8.0, clang++ &gt;= 6.0). To determine if your process supports AVX512-IFMA52, simply look for <computeroutput>HEXL_HAS_AVX512IFMA</computeroutput> during the configure step (see <ulink url="#compiling-intel-hexl">Compiling Intel HEXL</ulink>).</para>
</sect2>
<sect2 id="index_1autotoc_md5">
<title>Compile-time options</title>
<para>In addition to the standard CMake build options, Intel HEXL supports several compile-time flags to configure the build. For convenience, they are listed below:</para>
<para><table rows="11" cols="3"><row>
<entry thead="yes"><para>CMake option </para>
</entry><entry thead="yes"><para>Values </para>
</entry><entry thead="yes"><para></para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_BENCHMARK </para>
</entry><entry thead="no"><para>ON / OFF (default ON) </para>
</entry><entry thead="no"><para>Set to ON to enable benchmark suite via Google benchmark  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_COVERAGE </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable coverage report of unit-tests  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_DEBUG </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable debugging at large runtime penalty  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_DOCS </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable building of documentation  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_ENABLE_ADDRESS_SANITIZER </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable building with address sanitizer (ASan)  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_ENABLE_THREAD_SANITIZER </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable building with thread sanitizer (TSan)  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_ENABLE_UB_SANITIZER </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable building with undefined behavior sanitizer (UBSan)  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_EXPORT </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable export of Intel HEXL for use in 3rd-party project  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_SHARED_LIB </para>
</entry><entry thead="no"><para>ON / OFF (default OFF) </para>
</entry><entry thead="no"><para>Set to ON to enable building shared library  </para>
</entry></row>
<row>
<entry thead="no"><para>HEXL_TESTING </para>
</entry><entry thead="no"><para>ON / OFF (default ON) </para>
</entry><entry thead="no"><para>Set to ON to enable building of unit-tests  </para>
</entry></row>
</table>
</para>
</sect2>
<sect2 id="index_1autotoc_md6">
<title>Compiling Intel HEXL</title>
<para>The instructions to build Intel HEXL are common between Linux, MacOS, and Windows.</para>
<para>To compile Intel HEXL from source code, first clone the repository into your current directory. Then, to configure the build, call <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>-S<sp/>.<sp/>-B<sp/>build</highlight></codeline>
</programlisting></para>
<para>adding the desired compile-time options with a <computeroutput>-D</computeroutput> flag. For instance, to build Intel HEXL with debugging capabilities, call <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>-S<sp/>.<sp/>-B<sp/>build<sp/>-DHEXL_DEBUG=ON</highlight></codeline>
</programlisting></para>
<para>Then, to build Intel HEXL, call <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>--build<sp/>build</highlight></codeline>
</programlisting></para>
<para>This will build the Intel HEXL library in the <computeroutput>build/intel-hexl/lib/</computeroutput> directory.</para>
<para>To install Intel HEXL to the installation directory, run <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>--install<sp/>build</highlight></codeline>
</programlisting></para>
<para>To use a non-standard installation directory, configure the build with <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>-S<sp/>.<sp/>-B<sp/>build<sp/>-DCMAKE_INSTALL_PREFIX=/path/to/install</highlight></codeline>
</programlisting></para>
</sect2>
</sect1>
<sect1 id="index_1autotoc_md7">
<title>Testing Intel HEXL</title>
<para>To run a set of unit tests via Googletest, configure and build Intel HEXL with <computeroutput>-DHEXL_TESTING=ON</computeroutput> (see <ulink url="#compile-time-options">Compile-time options</ulink>). Then, run <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>--build<sp/>build<sp/>--target<sp/>unittest</highlight></codeline>
</programlisting></para>
<para>The unit-test executable itself is located at <computeroutput>build/test/unit-test</computeroutput> </para>
</sect1>
<sect1 id="index_1autotoc_md8">
<title>Benchmarking Intel HEXL</title>
<para>To run a set of benchmarks via Google benchmark, configure and build Intel HEXL with <computeroutput>-DHEXL_BENCHMARK=ON</computeroutput> (see <ulink url="#compile-time-options">Compile-time options</ulink>). Then, run <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>--build<sp/>build<sp/>--target<sp/>bench</highlight></codeline>
</programlisting></para>
<para>The benchmark executable itself is located at <computeroutput>build/benchmark/bench_hexl</computeroutput></para>
</sect1>
<sect1 id="index_1autotoc_md9">
<title>Using Intel HEXL</title>
<para>The <computeroutput>example</computeroutput> folder has an example of using Intel HEXL in a third-party project.</para>
</sect1>
<sect1 id="index_1autotoc_md10">
<title>Debugging</title>
<para>For optimal performance, Intel HEXL does not perform input validation. In many cases the time required for the validation would be longer than the execution of the function itself. To debug Intel HEXL, configure and build Intel HEXL with <computeroutput>-DHEXL_DEBUG=ON</computeroutput> (see <ulink url="#compile-time-options">Compile-time options</ulink>). This will generate a debug version of the library, e.g. <computeroutput>libintel_hexl_debug.a</computeroutput>, that can be used to debug the execution.</para>
<para><bold>Note</bold>, enabling <computeroutput>HEXL_DEBUG=ON</computeroutput> will result in a significant runtime overhead. </para>
</sect1>
<sect1 id="index_1autotoc_md11">
<title>Thread-safety</title>
<para>Intel HEXL is single-threaded and thread-safe.</para>
</sect1>
<sect1 id="index_1autotoc_md12">
<title>Documentation</title>
<para>Intel HEXL supports documentation via Doxygen and sphinx. To build documentation, first install <computeroutput>doxygen</computeroutput> and <computeroutput>graphviz</computeroutput>, e.g. <programlisting filename=".bash"><codeline><highlight class="normal">sudo<sp/>apt-get<sp/>install<sp/>doxygen<sp/>graphviz</highlight></codeline>
</programlisting></para>
<para>Then, configure Intel HEXL with <computeroutput>-DHEXL_DOCS=ON</computeroutput> (see <ulink url="#compile-time-options">Compile-time options</ulink>). </para>
<sect3 id="index_1autotoc_md13">
<title>Doxygen</title>
<para>To build Doxygen documentation, after configuring Intel HEXL with <computeroutput>-DHEXL_DOCS=ON</computeroutput>, run <programlisting><codeline><highlight class="normal">cmake<sp/>--build<sp/>build<sp/>--target<sp/>doxygen</highlight></codeline>
</programlisting></para>
<para>To view the generated Doxygen documentation, open the generated <computeroutput>build/docs/doxygen/html/index.html</computeroutput> file in a web browser.</para>
</sect3>
<sect3 id="index_1autotoc_md14">
<title>Sphinx</title>
<para>To build the sphinx documentation, install <computeroutput>sphinx</computeroutput> and required dependencies <computeroutput>breathe, m2r2</computeroutput>, e.g. <programlisting filename=".bash"><codeline><highlight class="normal">sudo<sp/>apt-get<sp/>install<sp/>python3-sphinx</highlight></codeline>
<codeline><highlight class="normal">pip3<sp/>install<sp/>breathe<sp/>m2r2</highlight></codeline>
</programlisting></para>
<para>Then, after configuring Intel HEXL with <computeroutput>-DHEXL_DOCS=ON</computeroutput>, run <programlisting filename=".bash"><codeline><highlight class="normal">cmake<sp/>--build<sp/>build<sp/>--target<sp/>docs</highlight></codeline>
</programlisting></para>
<para>To view the generated Sphinx documentation, open the generated <computeroutput>build/docs/sphinx/html/index.html</computeroutput> file in a web browser.</para>
</sect3>
</sect1>
<sect1 id="index_1autotoc_md15">
<title>Contributing</title>
<para>At this time, Intel HEXL does not accept external contributions. Feel free to discuss via issues.</para>
<para>For Intel developers, use <ulink url="https://pre-commit.com/">pre-commit</ulink> to validate the formatting of the code.</para>
<para>Before contributing, please run <programlisting filename=".bash"><codeline><highlight class="normal">make<sp/>check</highlight></codeline>
</programlisting></para>
<para>and make sure all unit tests and pre-commit checks pass.</para>
<sect2 id="index_1autotoc_md16">
<title>Repository layout</title>
<para>Public headers reside in the <computeroutput>intel-hexl/include</computeroutput> folder. Private headers, e.g. those containing Intel(R) AVX-512 code should not be put in this folder. </para>
</sect2>
</sect1>
    </detaileddescription>
  </compounddef>
</doxygen>
